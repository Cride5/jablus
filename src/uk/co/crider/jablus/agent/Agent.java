/*
 * Created on Mar 21, 2007
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package uk.co.crider.jablus.agent;

import uk.co.crider.jablus.Constants;
import uk.co.crider.jablus.EnvironmentInterface;
import uk.co.crider.jablus.Parameters;
import uk.co.crider.jablus.data.CompoundData;
import uk.co.crider.jablus.data.Data;

import java.awt.Color;
import java.util.Collection;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;

/**
 * Represents a decision making agent. All agents in
 * the model should be a subclass of this.
 * 
 * The agent object acts as a mediator between the environment
 * and agent implementations.
 * 
 * All signals from an agent to the environment are generated by
 * calling methods from this class.
 * 
 * All signals from the environment to agents are recieved via
 * methods of this class. */
public abstract class Agent extends CompoundData {
	
	/** Unique class ID */
    private static final long serialVersionUID = 8762889145117750621L;

    
    public static final int OFFSET = 2000;
    
    // Fields ----------------------------

    protected String name;
	private String dataFile;
	protected EnvironmentInterface env;
	protected Parameters params;
    protected Random random;
    protected Hashtable<Integer, Action> allActions;
	protected Hashtable<Integer, Collection<Integer>> actionTypes;
	protected Hashtable<Integer, Collection<Integer>> typeActions;
    protected Collection<Action> actionsToExecute;

    // Agent colours
	public static final Color[] COLOUR = new Color[]{
			new Color(237, 237, 237), // Grey for NONE
			new Color(215,   0,   0), // Red
			new Color(  0, 215,   0), // Green
			new Color(  0,   0, 215), // Blue
			new Color(225, 225,   0), // Yellow
			new Color(  0, 225, 225), // Cyan
			new Color(225,   0, 225), // Magenta
			new Color(225, 128,   0), // Orange
			new Color(128,   0,   0), // Dark Red
			new Color(  0, 128,   0), // Dark Green
			new Color(  0,   0, 128), // Dark Blue
			new Color(128, 128,   0), // Dark Yellow
			new Color(  0, 128, 128), // Dark Cyan
			new Color(128,   0, 128), // Dark Magenta
			new Color(172,  81,   0), // Brown
			new Color(255, 255, 255), // White
			new Color(128, 128, 128), // Grey
			new Color(  0,   0,   0)  // Black
	};
	

	/** Constructs a new agent */
	public Agent(String name, int id, EnvironmentInterface env, String dataFile, Parameters params){
		super(id, Constants.TEMPORAL_TIME, true);
		this.name = name;
		this.env = env;
		this.dataFile = dataFile;
		this.params = params;
		// TODO: need to create different seed for each agent in this simulation
	    random = new Random(params.AGENT_RANDOM_SEED);
	    allActions = new Hashtable<Integer, Action>();
		actionTypes = new Hashtable<Integer, Collection<Integer>>();
		typeActions = new Hashtable<Integer, Collection<Integer>>();
	    actionsToExecute = new LinkedList<Action>();
	    if(env != null) env.notifyNewAgent(this);
	}
	
	
	
	
	
	// Accessor methods -----------------------------------------

	/** Returns the agent's name */
	public final String getName(){ return name; }
	
	/** Return's the agent's type code */
	public abstract int getType();
	
	/** Returns the name of the data file contiaining this agent's data */
	public final String getDataFile(){ return dataFile; }
	
	
	
	
	
	// Actions -------------------------------------------------
	
	/** Returns the action schema corresponding to the given action,
	 * the action returned should not be tampered with, if tampering
	 * is required, use getActionExecutable instead */
	public final Action getActionSchema(int aId){
		return allActions.get(aId); }
	
	/** Returns a deep cloned copy of the action so that the
	 * values may be changed without affecting the base action */
	public final Action getActionExecutable(int aId){
		return (Action)allActions.get(aId).clone(); }
	
	/** Returns all actions this agent supports */
	public final Collection<Action> getActions(){
		return allActions.values(); }
	
	/** Returns the names of all actions belonging to the given type */
	public final Collection<Integer> getActions(int type){
		return actionTypes.get(type); }
	
	/** Returns all types this action belongs to */
	public final Collection<Integer> getActionTypes(Action a){
		return typeActions.get(a.id); }
	
	/** Returns whether this action is a member of the given type */
	public final boolean isActionType(Action a, int type){
		Collection<Integer> types = getActionTypes(a);
		return  types != null && types.contains(type); }
	
	/** Returns the actions to execute for this round */
	public final Collection<Action> getActionsToExecute(){
		return actionsToExecute; }
	
	/** Returns actions to execute which belong to the given type */
//	public final Collection<Action> getActionsToExecute(int type){
//		Collection<Action> c = new LinkedList<Action>();
//		for(Action a : actionsToExecute)
//			if(isActionType(a, type))
//				c.add(a);
//		return c;
//	}
	
	/** Any actions performed by an agent will cause this function to be called.
	 * It is the responsibility of the GUI to call this function when anything is
	 * done by a human */
	public final void addActionToPerform(Action action){
		if(!isActionPossible(action)) return;
		// Remove all incompatible actoins
		for(Iterator<Action> i = actionsToExecute.iterator(); i.hasNext();){
			Action a = i.next();
			if(!areActionsCompatible(action, a)){
//			if(!action.isCompatible(this, i.next())){
//System.out.println("NOT Compatible: " + a + "  ....   " + action);
				i.remove();
			}{
//System.out.println("compatible: " + a + "  ....   " + action);
			}
		}
		actionsToExecute.add(action);
	}
	
	/** Instantly performs an action, updating the model */
	public final void performAction(Action action){
		env.notifyAction(this, action);
	}
	
	/** Whether the the underlying environment will allow the
	 * named action to be executed on this round */
	public final boolean isActionPossible(int aId){
		return isActionPossible(allActions.get(aId)); }
	
	/** Whether the the underlying environment will allow the
	 * action to be executed on this round */
	public final boolean isActionPossible(Action action){
		return env.isActionPossible(action); }
	
	/** Whether two actions can be peformed on the same round */
	public abstract boolean areActionsCompatible(Action a1, Action a2);
	
	
	
	
	
	// Signals to the environment ------------------------------------------
	
	/** Once an agent has made their decisions and performed all actions
	 * associeated with them, this method is called to allow the environment
	 * to be affected by the actions */
	protected final void decisionsMade(){
		env.notifyActionSelectionDone(this); }	
	
	/** Called internally by agents when they have completed updating their state */
	protected final void doneUpdate(){
//System.out.println("Agent:" + actionsToExecute);
		env.notifyDoneUpdate(this); }

	
	
	
	// Signals from the environment ---------------------------------------
	
	/** Inform the agent that a new step has started, agents should
	 * override this method to carry out decision making tasks to
	 * ultimately create a set of new actions to execute on the
	 * environment  */
	public void notifyStartStep(){
		actionsToExecute.clear(); }

	/** Inform the agent that the current step has ended.
	 Provides the agent with an opportunity to update its beliefs */
	public abstract void notifyEndStep();
	
	
	
	
	// Generic methods -----------------------------------------------------

	/** @inheritDoc */
	public String toString(){
		return dataItems.toString();
	}
	
	/** @inheritDoc */
	public boolean equals(Object o){
		if(o instanceof Agent)
			return id == ((Agent)o).getId();
		return false;
	}

	/** Constructor for cloning this object */
	protected Agent(String name, int id, int key, Map<Integer, Data> dataItems,
			boolean hasFile, boolean containsDataSet){
		super(id, key, dataItems, hasFile, containsDataSet);
	}
	
	/** @inheritDoc */
	public abstract Object clone();
	
}
